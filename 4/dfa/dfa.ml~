type 'a fsa = { trans: (int * 'a * int) list; init: int; final: int list };;

let m1 = { 
    trans = [(0,'0',0);(0,'1',1);
             (1,'0',2);(1,'1',2);
             (2,'0',2);(2,'1',2)];
    init = 0;
    final = [1] }
;;

let m2 = { 
    trans = [(0,'0',0);(0,'0',1);
             (1,'0',2);(1,'1',2);
             (2,'0',2)];
    init = 0;
    final = [1] }
;;

let m3 = { 
    trans = [(0,'0',0);(0,'1',1);
             (1,'0',1);(1,'1',2)];
    init = 0;
    final = [1;2] }
;;

let rec member x = function
    [] -> false
  | y::l -> y=x || member x l;;

let rec union l = function 
    [] -> l
  | x::l' -> if member x l then union l l' else x::(union l l');;

let subseteq l l' = List.fold_right (fun x y -> if member x l' then y else false) l true;;

let equals l l' = subseteq l l' && subseteq l' l;;

let getlabels m = 
  let rec inner_getlabels = function
      [] -> []
    | (q,a,q')::l -> union [a] (inner_getlabels l)
  in inner_getlabels m.trans
;;

getlabels m1;;

let outlabels m q = 
  let rec inner_outlabels q = function
      [] -> []
    | (q',a,_)::l when q'=q -> union [a] (inner_outlabels q l)
    | _::l -> inner_outlabels q l
  in inner_outlabels q m.trans
;;

outlabels m2 2;;

let getstates m = 
  let rec inner_getstates = function 
      [] -> []
    | (q,a,q')::l -> union [q] (inner_getstates l)
  in inner_getstates m.trans
;;

getstates m1;;

let iscomplete m = 
  let qQ = getstates m in
  let lL = getlabels m in
  List.fold_left (&&) true (List.map (fun q -> subseteq lL (outlabels m q)) qQ)
;;

assert (iscomplete m1);;
assert (iscomplete m2 = false);;
assert (iscomplete m3 = false);;

let rec isbranch (q0,a,q1) = function
    [] -> false
  | (q0',b,q1')::l when q0'=q0 && b <> a -> true
  | (q0',b,q1')::l -> isbranch (q0,a,q1) l
;;

let rec isdeterministic = function
    [] -> true
  | (q,a,q')::l -> not (isbranch (q,a,q') l) && isdeterministic l
;;

let step q a m =  
  let rec step_list q a = function
      [] -> failwith "undefined state"
    | (q',b,q'')::l -> if q'=q && b=a then q'' else step_list q a l
  in step_list q a m.trans
;;

step 2 '0' m1;;


let rec step_star q w m = match w with
    [] -> q
  | a::w' -> step_star (step q a m) w' m
;;

step_star 0 ['0';'1';'1'] m1;;

let rec member x = function
    [] -> false
  | y::l -> y=x || member x l;;

let accept w m = member (step_star m.init w m) m.final;;


assert (accept ['0';'0';'1'] m1);;
assert (accept ['0';'0';'1';'1'] m1 = false);;
assert (accept ['1';'0';'0';'1'] m1 = false);;

assert (accept ['0';'1';'0';'1'] m3);;
assert (accept ['0';'0';'1';'0';'0'] m3);;
assert (accept ['0';'1';'1';'0'] m3 = false);;





(* Daniele Pusceddu *)

let rec uniq = function
    [] -> []
  | h::t -> h::uniq(List.filter (fun x -> x != h) t)
;;

let iscomplete m = 
  (* all labels used by m *)
  let sigma = uniq (List.fold_left (fun l (x,y,z) -> y::l) [] m.trans) in 
  let sigma_len = List.length sigma in
  
  (* all states of m *)
  let states = uniq (m.init::m.final@(List.fold_left (fun l (x,y,z) -> x::z::l) [] m.trans)) in 
  
  (* for all states, list of labels we can use in that state *)
  let paths = 
    List.map 
      (fun state -> uniq(List.fold_left (fun l (x,y,z) -> if x=state then y::l else l) [] m.trans)
      ) states
  in
  
  (* check if for all states, 
     cardinality of labels we can use in that state 
     corresponds to cardinality of sigma *)
  List.for_all (fun labels -> List.length labels = sigma_len) paths
;;

let m2 = { 
    trans = [(0,'0',0);(0,'0',1);
             (1,'0',2);(1,'1',2);
             (2,'0',2)];
    init = 0;
    final = [1] }
;;

iscomplete m2;;




(* elemento duplicato *)
let rec dup x l = match l with
    [] -> false
  | y::l' -> if y=x then true else dup x l'
;;
(* rimozione duplicati *)
let rec rem l = match l with
    [] -> []
  | x::l' -> if dup x l' then rem l' else x::[]@(rem l')
;;
(* lista stati *)
let rec stati m = match m with
    [] -> []
  | (x,y,z)::l -> x::z::[]@stati l
;;
(* lista parole *)
let rec w m = match m with
    [] -> []
  | (x,y,z)::l -> y::[]@(w l)
;;
(* true se contiene s*w, false altrimenti *)
let rec contiene y x m = match m with
    [] -> false
  | (a,b,c)::m' -> if a = y && b = x then true else contiene y x m'
;;
(* true se è presente nella lista, false altrimenti *)
let rec occ s w m = 
  match s with
    [] -> true
  | y::s' -> 
      match w with 
        [] -> false
      | x::w' -> if contiene y x m then occ s' w m else false
;;
(* iscomplete : 'a fsa -> bool *)
let iscomplete m = 
  occ (rem (stati m.trans)) (rem (w m.trans)) (m.trans) ;;

iscomplete m1;;
iscomplete m2;;


let m3 = { 
    trans = [(1,'1',2);(2,'1',1);(1,'1',1)];
    init = 1;
    final = [1] }
;;

iscomplete m3;;



(* Lista di etichette *)
let rec etichette w = match w with
    [] -> []
  | (x,y,z)::l -> y::(etichette w);;
(* Lista di stati *)
let rec stati w = match w with
    [] -> []
  | (x,y,z)::l -> x::z::(stati w);;
(* Stati di transizione *)
let rec st a b w = match w with
    [] -> []
  | (x,y,z)::l -> if a = x && y = b then z::(st a b l) else st a b l;;
(* Cerca un elemento in una lista *)
let rec isinside x l = match l with
    [] -> false
  | y::l' -> if x = y then true else isinside x l';;
(* Computa la parola *)
let rec tra q e m = match e with
    [] -> isinside q m.final
  | e'::[] -> if st q e' m.trans = []
      then false
      else isinside (List.hd (st q e' m.trans)) m.final
  | e'::t -> tra (List.hd (st q e' m.trans)) t m
;;
(* Valuta se l'automa è deterministico *)
let rec detcheck l = match l with
    [] -> true
  | (x,y,z)::t -> if List.length (st x y l) > 1 then false else detcheck t
;;

(* accept : 'a list -> 'a fsa bool *)
let accept w m = 
  if detcheck m.trans 
  then 
    if (List.length w) = 1 
    && isinside (List.hd (st m.init (List.hd w) m.trans)) m.final
    then true 
    else tra m.init w m
  else failwith "automa non deterministico"
;;

assert (accept ['0';'0';'1'] m1);;
assert (accept ['0';'0';'1';'1'] m1 = false);;
assert (accept ['1';'0';'0';'1'] m1 = false);;

assert (accept ['0';'1';'0';'1'] m3);;
assert (accept ['0';'0';'1';'0';'0'] m3);;
assert (accept ['0';'1';'1';'0'] m3 = false);;
